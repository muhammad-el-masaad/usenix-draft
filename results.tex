\section{Experimental Evaluation and Results}



\begin{table*}[ht]
\centering
\caption{Performance of hill-climbing MSE attack on 11 sequential benchmarks from the MCNC set. Numbers are average number of key bits correctly recovered by attack for 5 runs on each benchmark.}
\label{my-label}
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|l|}
\hline
\multirow{4}{*}{} & \multicolumn{12}{c|}{Number of Key Bits}                                                                                                                        \\ \cline{2-13} 
                  & \multicolumn{4}{c|}{32}                             & \multicolumn{4}{c|}{64}                             & \multicolumn{4}{c|}{128}                            \\ \cline{2-13} 
                  & \multicolumn{3}{l|}{Correctly Recovered} &          & \multicolumn{3}{l|}{Correctly Recovered} &          & \multicolumn{3}{l|}{Correctly Recovered} &          \\ \cline{2-13} 
                  & Min         & Max         & Avg.         & Time (s) & Min         & Max         & Avg          & Time (s) & Min         & Max         & Avg          & Time (s) \\ \hline
dk16              &           &           & 24.5         &          &           &           &         44 &          &           &           &          &          \\ \hline
ex1              &           &           & 23.7         &          &           &           &            &          &           &           &          &          \\ \hline
keyb             &           &           & 22.4         &          &           &           &          &          & 
&           &          &          \\ \hline
planet1             &           &           & 21.13         &          &           &           &          &         &           &           &          &          \\ \hline
planet             &           &           & 20.8         &          &           &           &      33    &         &           &           &          &          \\ \hline
s1a             &           &           & 20         &          &           &           &          &      &           &           &          &          \\ \hline
s1             &           &           & 18          &          &           &           &         37 &         &           &           &          &          \\ \hline
sand             &           &           & 17.8         &          &           &           &        36.6  &         &           &           &          &          \\ \hline
scf             &           &           & 21.2         &          &           &           &         40.2 &         &           &           &         75 &          \\ \hline
styr             &           &           & 18.8         &          &           &           &         38.6 &         &           &           &          &          \\ \hline
tbk             &           &           & 22.2         &          &           &           &         36 &         &          &           &          &          \\ \hline

\end{tabular}
\end{table*}

%Results below are for the case where XOR gates are inserted at random, and inverters are left where they are (no moving inverters up and down the netlist). No care is taken to avoid critical paths in the netlist when inserting inverters, but output wires are avoided. 

%When initial guess is selected at random, 15-19 bits of a 24-bit key are successfully recovered. (didn't study the effect of key gate locations on performance of the attack)

%24, 21, 22, 23, 22  32
%7, 15, 11, 14, 13  48
%17, 16 64

%Even when the initial guess is the exact complement of the correct key, a significant portion of key bits is correctly recovered.

\subsection{Performance Evaluation on Benchmark Circuits}
To provide an insight on the once can expect from locking a VLSI design using our procedure, we implement our procedure using PHP and the ABC system \cite{} for BDD construction, and use the implemented tool chain to encrypt sequential circuits from the MCNC benchmark suite. As a baseline, we also report the overhead of locking the same circuits using XOR locking. The results are reported in Table ??.

We note that one can use other, more BDD-targeted synthesis tools (the BDS and FDD tools from the Universities of Amherst and Toronto, respectively for example) in place of ABC as a backend --- to obtain implementations with potentially less area and delay overheads. Whether such tools are better equipped to synthesis circuits resulting from our locking synthesis tool-chain, we leave as topic for future work.

\begin{table*}
\caption{Area and delay overheads of our BDD-based obfuscation technique when implemented on the alu4 benchmark. }
\begin{tabular}{ | c | c | c | c | c | }
\hline
 Benchmark Name & Area Overhead (32-bit) & Delay Overhead (32-bit)  & Area Overhead (64-bit) & Delay Overhead (64-bit) \\
\hline
bbara.kiss2&3.91&1.36&5.72&1.68\\
bbsse.kiss2&2.22&1.27&3.16&1.42\\
beecount.kiss2&4.04&1.88&11.60&2.36\\
cse.kiss2&1.72&1.09&0.00&0.00\\
dk14.kiss2&2.55&1.50&4.08&1.60\\
dk15.kiss2&3.56&1.32&5.88&1.70\\
dk16.kiss2&1.46&1.16&1.94&1.24\\
dk17.kiss2&3.49&1.60&5.69&1.69\\
dk512.kiss2&3.37&1.45&5.35&1.58\\
donfile.kiss2&1.75&1.36&2.66&1.38\\
ex1.kiss2&1.68&1.13&2.28&1.20\\
ex2.kiss2&2.13&1.38&3.08&1.53\\
ex3.kiss2&3.23&1.53&5.32&1.58\\
ex4.kiss2&2.76&1.48&4.31&1.69\\
ex5.kiss2&3.11&1.41&5.18&1.63\\
ex6.kiss2&2.96&1.30&4.29&1.42\\
ex7.kiss2&3.34&1.47&5.40&1.60\\
keyb.kiss2&1.70&1.08&2.27&1.15\\
kirkman.kiss2&2.17&1.17&3.02&1.23\\
mark1.kiss2&2.66&1.55&3.68&1.84\\
opus.kiss2&2.61&1.41&4.06&1.52\\
planet1.kiss2&1.26&1.04&1.61&1.22\\
planet.kiss2&1.27&1.27&1.61&1.26\\
s1a.kiss2&1.45&1.15&1.87&1.22\\
s1.kiss2&1.33&1.10&1.66&1.18\\
sand.kiss2&1.31&1.13&1.56&1.22\\
scf.kiss2&1.14&1.06&1.33&1.04\\
sse.kiss2&2.29&1.24&3.20&1.47\\
styr.kiss2&1.36&1.03&1.72&1.09\\
tbk.kiss2&1.34&1.00&1.47&1.10\\
train11.kiss2&3.95&1.72&&\\
\hline
\end{tabular}
\end{table*}

%c880 (no random restarts) 
%24 17 72.38 18 66.75 14 43.2 20 67.23 16 82.57

%32 20 89.55 23 56.06 20 115.88 22 125.43 21 140.16

%48 36 223.74 37 209 31 164.34 38 151.75 30 128.42

%64 43 258.8 45 413.56 45 371.98 43 224.99

%80 48 518.51 57 488.26 62 591.109 55 556.18

%96 70 539.96 69 636.91 73 819.2 73 660.38 72 795.82

%112 74 968.78 89 1079.58 74 698.56 89 1090.43 72 1086.43

%128 94 1403.94 92 1234.59 82 1166.71 94 1285.91 94 1243.16

%c880 - 32-bit with random restarts
%Number of correctly recovered bits      Time Taken (s)
%23                                                         1645.87
%24                                                         1458.24
%27                                                         1667.95
%25                                                         1653.95
%25                                                         1813.47

%I ran the attack on c1908 (a bigger benchmark) encrypted with a 24-bit long key.. For five random initial key guesses: from 12 to 15 bits of the key were correctly recovered.

%For 64-bit keys:
%Number of correctly recovered bits      Time Taken (s)
%48                                                         5385.41
%44                                                         4790.02
%48                                                         4686.72
%48                                                         5035.48
%47                                                         3780.07

%For 128-bit keys:
%Number of correctly recovered bits      Time Taken (s)
%101                                                       8585.73
%96                                                         8311.26
%93                                                         8164.93
%94                                                         8341.93
%92                                                         6334.29

%BDS actually just finished synthesizing the new smaller BDD, but the results are similar to those of ABC.. The area overhead is about 19X and the delay overhead is still 2.4X




%Number of gates: 632
%Area: 1088080.00
%Delay: 6.63

%For BDS global BDD synthesis (when fed with BDD rep. generated by ABC):

%Number of gates: 620
%Area: 1060240.00
%Delay: 7.50

%When encrypting with 16 key gates: 
%Number of gates: 1048 
%Area: 1765984.00
%Delay: 12.19

%When encrypting with 32 key gates:
%Number of gates: 1360
%Area: 2330672.00
%Delay: 9.51

%1508928.00 instead of 1765984.00 (1.4X instead 1.6X) sound like a more reasonable area overhead for encrypting alu4 with 16 key gates?
%Delay is 13.56

