\section{Background: Circuit Locking}

In this section, we describe the workings of the original locking mechanism --- proposed by Roy et al.~\cite{roy2008epic} --- in detail. As a representative of other locking schemes that have subsequently been proposed in the literature, we also describe the technique developed by Rajendran et al. in~\cite{rajendran2012logic}. %We then describe synthesis, [blah blah blah].
%We note that both techniques assume a gate-level netlist to be locked as input, and do not make any assumptions on how the netlist was generated. %to fix a certain vulnerability in Roy's scheme.

%illustrate how how logic locking works using two example locking mechanisms from the literature. 
\subsection{XOR locking~\cite{roy2008epic}}
XOR locking, introduced by Roy et al.~\cite{roy2008epic}, is the first combinational\footnote{There were locking mechanisms before, but they were sequential [reword]} locking mechanism that was proposed in the literature. The algorithm was set forth as part of a larger scheme to ``End Piracy of Integrated Circuits", or EPIC. In addition to XOR locking, Roy's technique involves adding on-chip structures that protect the correct key from being extracted by reverse-engineering an activated IC, and also provisions for chip activation by the foundry, while still giving the designer control over the number of chips that are activated. To do so, EPIC uses a number of keys. Roy et al. use the term \emph{common key} (CK) to distinguish the key used by the locking mechanism from other keys used in EPIC (CK is common to each chip, while other keys are instance specific). We adopt this terminology from here onwards.

%\subsection{XOR locking}

Given a netlist to be locked using common key $CK$, the XOR locking algorithm proceeds as follows. For each bit of $CK$, the algorithm selects a wire in the netlist and inserts either an XOR or an XNOR gate into the wire; with the side-input of the gate connected to the corresponding bit of the common-key register. The choice of whether to insert an XOR or an XNOR gate for each bit of $CK$ is made so the functionality of the netlist is preserved when $CK$ appears in the common-key register: if a bit is 0, an XOR gate is inserted; if a bit is 1, an XNOR gate inserted. If an XNOR gate is inserted, it is immediately replaced by an XOR gate followed by an inverter. 

It is clear that if the designer's common key appears in the common-key register, the circuit will function as the designer intended. A incorrect key bit applied to the input of one added key gate, on the other hand, corresponds corresponds to an inverter being placed along the wire. This presumably changes the functionality of the circuit. While this is in general not guaranteed (a simple counter-example --- noted by Roy et al. ---  is an XOR tree), Roy et al. observe experimentally that the number of valid keys for practical designs is relatively small~\cite{roy2008epic}.

Roy et al. in addition note two things regarding XOR locking. First, as an added measure to conceal the value of common key bits, each added inverter (corresponding to a common key bit of 0) can be moved up and down the netlist (using DeMorgan's laws). Second, Roy et al. prescribe that the locking procedure must take care to avoid critical paths in when selecting wires for key-gate insertion, so as not to affect critical path delays. This is possible, since locking takes place at a point in the design flow in which the critical paths in the circuit are known, i.e., \emph{post-synthesis}.

%These inverters are then moved up and down the netlist --- in a random manner --- using DeMorgan's laws. It is worth noting that the Roy et al. specify that in order to minimize the impact of the added key gates on the timing of the netlist, the designer must take care to avoid critical paths in the netlist when selecting wires for key gate insertion. selecting a set of random wires 
%The idea behind combinational locking is to modify the gate-level netlist of a design to be protected; so a chip produced from the resulting mask functions as intended only when a certain value, referred to as the \emph{common key} (CK) is programmed into the chip. An elegant way of doing this is illustrated in Figure \ref{}\cite{roy2008epic}, where a set of wires is selected at random in the gate-level netlist of a hypothetical design, and an XOR gate is inserted along each wire with one of the inputs connected to a distinct bit of the common key register. Depending on the value of the corresponding common key bit, an inverter may have to be added at the output of the XOR gate to preserve the circuit functionality. To prevent the fab from deducing the values of the common key bits by simply looking at the netlist, these inverters are then moved up and down the netlist (using DeMorgan's laws). The technique is referred to as XOR locking, and was first proposed by Roy et al.~\cite{roy2008epic}.


%\paragraph{Example} XOR locking works as follows. Given the gate-level netlist of the design to be protected, the designer begins by generating a \emph{common key} (CK)\footnote{The same key unlocks any copy of the chip fabricated from the same mask; presumably why Roy at }. For each key bit, the designer selects a random wire in the netlist and inserts either an XOR or an XNOR gate along the wire. The extra input of the XOR gate becomes the key \emph{input} corresponding to that gate. The designer chooses which type of gate to insert (XOR or XNOR) based on on the value of the corresponding key bit. The designer then replaces each added XNOR gate with an XOR gate followed by inverter. These inverters are then moved up and down the netlist --- in a random manner --- using DeMorgan's laws. It is worth noting that the Roy et al. specify that in order to minimize the impact of the added key gates on the timing of the netlist, the designer must take care to avoid critical paths in the netlist when selecting wires for key gate insertion.

%The reader can see that 
%adds an extra \emph{key input} to the netlist, and inserts an XOR gate at a randomly selected location in the netlist, and The designer then adds extra \emph{key inputs} to the netlist that drive XOR gates inserted along randomly selected wires in the netlist. 
%Each added key inpt drives a distinct key gate. When the An example of a locking synthesis procedure is the following. Take the behavioral description $f$ and do conventional (locking-free) synthesis to obtain a gate-level implementation. Select $m$ internal wires in the resulting circuit uniformly at random, and associate each with a distinct key bit. Depending on whether the corresponding key bit is 0 or 1, insert either an XOR gate or an XOR gate along each wire, with one input of the gate connecting to the wire's driver and the other input dangling (this is illustrated in Figure ??). Replace each XNOR gate with an XOR gate followed by an inveror then use DeMorgan's laws to move these inverters to random locations up or down the netlist. Provide the resulting netlist as the synthesis output.

\newcommand{\dummyfig}[1]{
  \centering
  \fbox{
    \begin{minipage}[c][0.20\textheight][c]{0.45\textwidth}
      \centering{#1}
    \end{minipage}
  }
}

%% This part makes a figure
%\begin{figure}[h]
%  \dummyfig{Dummy Figure Label} 
%  \caption{XOR locking.}
%  \label{fig:dummy1}
%\end{figure}

%The reader can see that such an output satisfies the first correctness criterion in Defintion ??. With careful selection of wires in the second step, it is conceivable that it can be made to additionally satisfy the second correctness criterion. However, as we will see later, the procedure does not satisfy our condition for secure synthesis, and as such, must not be considered secure. We use this example locking procedure for its simplicity to illustrate how a basic locking procedure might work. The mechanism was proposed by \cite{} as part of a larger ``purely combinational" IC activation scheme and is known in the lierature as XOR locking \cite{}. It is worth noting that the authors specify that to minimize impact on the delay characteristics of the final chip, all critical paths in the netlist must be avoided when selecting wires for XOR insertion in Step ??.

\subsection{Interference-Based Locking~\cite{rajendran2012logic}}
Interference-based locking was developed by Rajendran et al.~\cite{rajendran2012logic} to fix a certain vulnerability in XOR locking that arises when the foundry has access to a functional (unlocked) IC\footnote{Recall that this is not the case in our threat model}. Since XOR locking does not prescribe criteria on how wires in a netlist should be selected for key gate insertion (other than that they must not lie on a critical circuit path); Rajendran observes that the algorithm may output locked netlists that are easily ``decipherable", given access to an unlocked IC. An example is when a key gate's ``fanin" and ``fanout" cones do not contain any other key gates. In such case, the attacker can use an EDA tool to find an input pattern that when applied to the locked netlist propagates the output of the key gate to a circuit output. By observing the response of the funtional IC to this input pattern, the attacker determines the output of the key gate, and consequently the value of the corresponding key bit~\cite{rajendran2012security}. Other problematic configurations are also possible~\cite{rajendran2012logic}. To avoid such configurations, Rajendran et al. propose that key gates be inserted so they ``interfere" with each other, in the sense that determining the output of one without making assumptions about the outputs of other key gates --- is impossible~\cite{rajendran2012logic}. The paper describe a concrete algorithm to inset key gates in a netlist so they satisfy this property.

\subsection{Other Locking Schemes}
Other locking schemes that have been proposed in the literature include bus-based locking~\cite{roy2008protecting}, proposed by Roy, Koushanfar, and Markov as a higher-level locking mechanism that operates on the bus level, fault-analysis based ``encryption" by Rajendran et al. \cite{rajendran2015fault,rajendran2012logic} that attempts to ensure wrong keys ``corrupt" circuit outputs, ``barrier"-based locking~\cite{baumgartenpreventing} proposed by Baumgarten, Tyagi, and Zambreno to ``increase the flexibility of combinational locking" by increasing the size of the key space, and multiplexer-based locking, proposed by Plaza and Markov~\cite{plaza2015solving} to allow IC testing by the foundry before activation.

\subsection{Logic Synthesis}
In the context of EDA, synthesis refers to the process of converting a behavioural description of a circuit, written in a hardware description language like Verilog or VHDL, to a low-level implementation in terms of logic gates (AND, OR, etc.). The process may be compared to that of compiling a computer program written in a high-level programming language into a lower-level language like Assembly or machine language, suitable for execution by a processor. Like compilation, logic synthesis is typically done by a computer program, referred to as a \emph{synthesis tool}. A synthesis tool attempts to produce an implementation of the input behavioural description that is optimal in certain performance metrics (in the VLSI domain, these would be things like the area, delay, and power of the implemetation). By doing so, a hardware designer is enabled to focus on the behavioural aspects of the hardware to be engineered, and leave the details of how to construct an optimal implementation to the synthesis tool. 

Hardware description languages use a design abstraction referred to as the register-transfer level (RTL), in which a digital circuit is modeled in terms of the flow of data between hardware registers, and the logical operations performed on those data. 
%The RTL is then mapped into the gate-level netlist, in a certain target technology.
A common characteristic of all existing locking mechanisms published in the literature is that they perform their locking modifications on \emph{netlists}, which are typically the result of a an earlier synthesis step in the design flow; performed on such RTL. This, it turns out that, introduces a significant vulnerability in these schemes, as we prove in this paper.

