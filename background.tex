\section{Background: Circuit Locking}

In this section, we describe the workings of the original locking mechanism --- proposed by Roy et al.~\cite{roy2008epic} --- in detail. As a representative of other locking schemes that have subsequently been proposed in the literature, we also describe the technique developed by Rajendran et al. in~\cite{rajendran2012logic}. We note that both techniques assume a gate-level netlist to be locked as input, and do not make any assumptions on how the netlist was generated. %to fix a certain vulnerability in Roy's scheme.

%illustrate how how logic locking works using two example locking mechanisms from the literature. 
\subsection{XOR locking~\cite{roy2008epic}}
XOR locking, introduced by Roy et al.~\cite{roy2008epic}, is the first combinational\footnote{There were locking mechanisms before, but they were sequential [reword]} locking mechanism that was proposed in the literature. The algorithm was set forth as part of a larger scheme to ``End Piracy of Integrated Circuits", or EPIC. In addition to XOR locking, Roy's technique involves adding on-chip structures that protect the correct key from being extracted by reverse-engineering an activated IC, and also provisions for chip activation by the foundry, while still giving the designer control over the number of chips that are activated. To do so, EPIC uses a number of keys. To distinguish the key used by the locking mechanism from other keys used by the technique, Roy et al. use the term \emph{common key} (CK), as it is the only key that is common to each chip. We adopt this terminology from here onwards.

%\subsection{XOR locking}

Given a netlist to be locked using common key $CK$, the XOR locking algorithm proceeds as follows. For each bit of $CK$, the algorithm selects a random wire in the netlist and inserts either an XOR or an XNOR gate into the wire; with the side-input of the gate connected to the corresponding bit of the common-key register. The choice of whether to insert an XOR or an XNOR gate for each bit of $CK$ is made so the functionality of the netlist is preserved when $CK$ appears in the common-key register: if a bit is 0, an XOR gate is inserted; if a bit is 1, an XNOR gate inserted. If an XNOR gate is inserted, it is immediately replaced by an XOR gate followe by an inverter. 

Roy et al. note two things regarding XOR locking. First, as an added measure to conceal the value of the common key bits, each added inverter be moved up and down the netlist (using DeMorgan's laws). Second, since locking takes place post-synthesis, the locking algorithm can take care to avoid critical paths in the circuit when selecting wires for key-gate insertion, . 

An incorrect key bit applied to the input of one added key gate however corresponds to an inverter being placed along the wire. This presumably changes the functionality of the circuit.

%These inverters are then moved up and down the netlist --- in a random manner --- using DeMorgan's laws. It is worth noting that the Roy et al. specify that in order to minimize the impact of the added key gates on the timing of the netlist, the designer must take care to avoid critical paths in the netlist when selecting wires for key gate insertion. selecting a set of random wires 
%The idea behind combinational locking is to modify the gate-level netlist of a design to be protected; so a chip produced from the resulting mask functions as intended only when a certain value, referred to as the \emph{common key} (CK) is programmed into the chip. An elegant way of doing this is illustrated in Figure \ref{}\cite{roy2008epic}, where a set of wires is selected at random in the gate-level netlist of a hypothetical design, and an XOR gate is inserted along each wire with one of the inputs connected to a distinct bit of the common key register. Depending on the value of the corresponding common key bit, an inverter may have to be added at the output of the XOR gate to preserve the circuit functionality. To prevent the fab from deducing the values of the common key bits by simply looking at the netlist, these inverters are then moved up and down the netlist (using DeMorgan's laws). The technique is referred to as XOR locking, and was first proposed by Roy et al.~\cite{roy2008epic}.

While XOR locking does not in general guarantee that a locked netlist functions as intended only for the designer's chosen common key (a simple counter-example --- noted by Ro et al. ---  is an XOR tree), Roy et al. observe experimentally that the number of valid keys for practical designs is typically retly small ().
%\paragraph{Example} XOR locking works as follows. Given the gate-level netlist of the design to be protected, the designer begins by generating a \emph{common key} (CK)\footnote{The same key unlocks any copy of the chip fabricated from the same mask; presumably why Roy at }. For each key bit, the designer selects a random wire in the netlist and inserts either an XOR or an XNOR gate along the wire. The extra input of the XOR gate becomes the key \emph{input} corresponding to that gate. The designer chooses which type of gate to insert (XOR or XNOR) based on on the value of the corresponding key bit. The designer then replaces each added XNOR gate with an XOR gate followed by inverter. These inverters are then moved up and down the netlist --- in a random manner --- using DeMorgan's laws. It is worth noting that the Roy et al. specify that in order to minimize the impact of the added key gates on the timing of the netlist, the designer must take care to avoid critical paths in the netlist when selecting wires for key gate insertion.

%The reader can see that 
%adds an extra \emph{key input} to the netlist, and inserts an XOR gate at a randomly selected location in the netlist, and The designer then adds extra \emph{key inputs} to the netlist that drive XOR gates inserted along randomly selected wires in the netlist. 
%Each added key inpt drives a distinct key gate. When the An example of a locking synthesis procedure is the following. Take the behavioral description $f$ and do conventional (locking-free) synthesis to obtain a gate-level implementation. Select $m$ internal wires in the resulting circuit uniformly at random, and associate each with a distinct key bit. Depending on whether the corresponding key bit is 0 or 1, insert either an XOR gate or an XOR gate along each wire, with one input of the gate connecting to the wire's driver and the other input dangling (this is illustrated in Figure ??). Replace each XNOR gate with an XOR gate followed by an inveror then use DeMorgan's laws to move these inverters to random locations up or down the netlist. Provide the resulting netlist as the synthesis output.

\newcommand{\dummyfig}[1]{
  \centering
  \fbox{
    \begin{minipage}[c][0.20\textheight][c]{0.45\textwidth}
      \centering{#1}
    \end{minipage}
  }
}

%% This part makes a figure
\begin{figure}[h]
  \dummyfig{Dummy Figure Label} 
  \caption{XOR locking.}
  \label{fig:dummy1}
\end{figure}

%The reader can see that such an output satisfies the first correctness criterion in Defintion ??. With careful selection of wires in the second step, it is conceivable that it can be made to additionally satisfy the second correctness criterion. However, as we will see later, the procedure does not satisfy our condition for secure synthesis, and as such, must not be considered secure. We use this example locking procedure for its simplicity to illustrate how a basic locking procedure might work. The mechanism was proposed by \cite{} as part of a larger ``purely combinational" IC activation scheme and is known in the lierature as XOR locking \cite{}. It is worth noting that the authors specify that to minimize impact on the delay characteristics of the final chip, all critical paths in the netlist must be avoided when selecting wires for XOR insertion in Step ??.

\subsection{Interference-based Locking}
The second technique, developed by Rajendran et al.~\cite{rajendran2012logic}, fixes a certain vulnerability in XOR locking that arises when the foundry has access to a functional (unlocked) IC\footnote{Recall that this is not the case in our threat model}. Rajendran's algorithm is based on a certain testing-based notion of interference between key bits, so we refer to their technique as \emph{interference-based locking}.
Rajendran et al. observe that unless the are chosen judiciously, it may be possible for the foundry to , by reducing the problem to one of . This happens when key gates are isolated.